-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.4d)
-- from file main.cph, on 2018-03-14 at 11:22:16, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;

entity accumulator is
   port (
    in0_empty: in std_logic;
    in0: in std_logic_vector(15 downto 0);
    in0_rd: out std_logic;
    out0_full: in std_logic;
    out0: out std_logic_vector(15 downto 0);
    out0_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end accumulator;

architecture FSM of accumulator is
    type t_enum1 is (ACC,RES);
    signal state : t_enum1;
    signal n_state : t_enum1;
    signal en_state : boolean;
    signal acc : signed(15 downto 0);
    signal n_acc : signed(15 downto 0);
    signal en_acc : boolean;
    signal count : unsigned(2 downto 0);
    signal n_count : unsigned(2 downto 0);
    signal en_count : boolean;
begin
  comb: process(in0, in0_empty, out0_full, count, acc, state)
    variable p_data : signed(15 downto 0);
  begin
    -- count=7, in0.rdy, state=ACC / p_data=in0, state:=RES, acc:=acc+p_data
    if count=to_unsigned(7,3) and in0_empty='0' and state=ACC then
      p_data := from_std_logic_vector(in0,16);
      in0_rd <= '1';
      n_state <= RES;
      en_state <= true;
      n_acc <= (acc) + (p_data);
      en_acc <= true;
      out0 <= (others => 'X');
      out0_wr <= '0';
      n_count <= count;
      en_count <= false;
    -- in0.rdy, state=ACC / p_data=in0, state:=ACC, acc:=acc+p_data, count:=count+1
    elsif in0_empty='0' and state=ACC then
      p_data := from_std_logic_vector(in0,16);
      in0_rd <= '1';
      n_state <= ACC;
      en_state <= true;
      n_acc <= (acc) + (p_data);
      en_acc <= true;
      n_count <= (count) + (to_unsigned(1,3));
      en_count <= true;
      out0 <= (others => 'X');
      out0_wr <= '0';
    -- state=RES, out0.rdy / state:=ACC, wr(out0,acc), count:=0, acc:=0
    elsif state=RES and out0_full='0' then
      n_state <= ACC;
      en_state <= true;
      out0 <= std_logic_vector(acc);
      out0_wr <= '1';
      n_count <= to_unsigned(0,3);
      en_count <= true;
      n_acc <= to_signed(0,16);
      en_acc <= true;
      in0_rd <= '0';
    else
      in0_rd <= '0';
      out0_wr <= '0';
      out0 <= (others => 'X');
      en_state <= false;
      en_acc <= false;
      en_count <= false;
      n_state <= state;
      n_acc <= acc;
      n_count <= count;
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
      state <= ACC;
      acc <= "0000000000000000";
      count <= "000";
    elsif rising_edge(clock) then
      if ( en_state ) then
        state <= n_state after 1 ns;
      end if;
      if ( en_acc ) then
        acc <= n_acc after 1 ns;
      end if;
      if ( en_count ) then
        count <= n_count after 1 ns;
      end if;
    end if;
  end process;
end FSM;

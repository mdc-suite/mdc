package it.mdc.tool.powerSaving

import java.text.SimpleDateFormat
import java.util.Date
import java.util.List
import net.sf.orcc.df.Network

import it.mdc.tool.core.sboxManagement.SboxLut
import it.mdc.tool.core.ConfigManager
import java.util.ArrayList
import java.util.Map
import java.util.Set
import java.util.HashSet
import java.util.HashMap
import net.sf.orcc.df.Connection
import net.sf.orcc.util.OrccLogger

/*
 * A CPF Template file printer
 * 
 * @author Tiziana Fanni
 */
class CpfPrinter {
	
	var ConfigManager configManager;
	
	var List<SboxLut> luts;
	
	var List<Network> networks;
	
	var Map<String,Set<String>> logicRegions;
	
	var Map<String,Set<String>> netRegions;
	
	var Map<String, Integer> logicRegionID;
	
	var Set<String> powerSets;
	
	var Map<String,HashSet<String>> LrCrossIsoMap;
	
	var Map<String,HashSet<String>> Compl_LrCrossIsoMap;
	
	var Map<String, Integer> powerSetIsoAmount;
	var Map<String, Integer> powerSetIsoAmount_full;
	
	var Map<String,Boolean> logicRegionsSeqMap;
	
	def headerComments(){				
		var dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		var date = new Date();
		'''
		###############################################################################
		# CPF Template file automatically generated by:
		# Multi-Dataflow Composer tool - Power Saving
		# Date: «dateFormat.format(date)»
		###############################################################################
		'''	
	}
	
	
	//For each PDx, find PDs which are on when PDx is off
	def findLrCrossIso(){
		for(String lr : powerSets) {
			LrCrossIsoMap.put(lr, new HashSet<String>());		
			for(String net : netRegions.keySet()) {	
				if(!netRegions.get(net).contains(lr)){
					for(String region : netRegions.get(net))
						if(!LrCrossIsoMap.get(lr).contains(region) && powerSets.contains(region)){
							LrCrossIsoMap.get(lr).add(region)													
						}
					}
				}
			}
		}
		
		
		//For each PDx, find PDs which are on when PDx is on
	def compl_LrCrossIso(){
		for(String lr : powerSets) {
			Compl_LrCrossIsoMap.put(lr, new HashSet<String>());		
				for(String cross_lr: powerSets)
					if(!LrCrossIsoMap.get(lr).contains(cross_lr))
							Compl_LrCrossIsoMap.get(lr).add(cross_lr);
		}
	}	
		
		
	// find isolation cells number (only for ALBA custom protocol)
	def findIsoCellsAmount(Network network){
		for(String lr : powerSets) {
			powerSetIsoAmount.put(lr,0);
			powerSetIsoAmount_full.put(lr,0);	
				
			for(Connection connection : network.connections) {
				
				if(logicRegions.get(lr).contains(connection.source.label) &&
						!logicRegions.get(lr).contains(connection.target.label)) {
							var size = connection.size
										if(size==null) {
											size = connection.sourcePort.type.sizeInBits
										}						
							var flag = true;													
							for(String crossLr : Compl_LrCrossIsoMap.get(lr)){
								if(logicRegions.get(crossLr).contains(connection.target.label)){
									flag = false;}								
							}
								if(flag){
										
								 powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size + 16 + 1);
								 //powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size);
								}
								powerSetIsoAmount_full.put(lr,powerSetIsoAmount_full.get(lr)+ size + 16 + 1);
				}
				
				if (logicRegions.get(lr).contains(connection.target.label) &&
						!logicRegions.get(lr).contains(connection.source.label)) {						
						var flag = true; 
						for(String crossLr : Compl_LrCrossIsoMap.get(lr)){
							if (logicRegions.get(crossLr).contains(connection.source.label))
								flag = false;
						}
							if(flag){
								powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + 1);
								//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
							}
							powerSetIsoAmount_full.put(lr,powerSetIsoAmount_full.get(lr) + 1);
				}
			}
		}
	}

	
	/* 	// find isolation cells number (only for ALBA custom protocol)
	def findIsoCellsAmount(Network network){
		for(String lr : powerSets) {
			powerSetIsoAmount.put(lr,0);		
			for(Connection connection : network.connections) {
				if(logicRegions.get(lr).contains(connection.source.label) &&
						!logicRegions.get(lr).contains(connection.target.label)) {
							var size = connection.size
							if(size==null) {
								size = connection.sourcePort.type.sizeInBits
							}
							//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size + 16 + 1);
							powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
				}
				if (logicRegions.get(lr).contains(connection.target.label) &&
						!logicRegions.get(lr).contains(connection.source.label))  {
							//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + 2);
							powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
				}
			}
			
		}
		
	}*/
	
	
	def computeNets() {
		networks.addAll(luts.get(0).getNetworks());
	}
	
	
	def createPowerDomains() {			
		'''
		create_power_domain -name PDdef -default	
					
		«FOR lr: powerSets»
		create_power_domain -name PD«logicRegionID.get(lr)» -instances {«FOR inst: logicRegions.get(lr)»«inst» «ENDFOR»}\
		-shutoff_condition {!powerController_0/pw_switch_en«logicRegionID.get(lr)»} -base_domains {PDdef}
		
		«ENDFOR»			
		'''
	}	
	
	def createPowerModes(){	
		'''	
		create_power_mode -name PMdef -domain_conditions {PDdef@on «FOR lr: powerSets»PD«logicRegionID.get(lr)»@on «ENDFOR»} -default
		«FOR network : networks»
		#«network.getSimpleName()»
		create_power_mode -name PM«configManager.getNetworkId(network.getSimpleName())» -domain_conditions {PDdef@on «FOR reg : netRegions.get(network.getSimpleName())»«IF powerSets.contains(reg)»PD«logicRegionID.get(reg)»@on «ENDIF»«ENDFOR»}
		«ENDFOR»		
		'''
	}
	
	def createIsolationRules(){
		'''
		«FOR lr: powerSets»
		# PD«logicRegionID.get(lr)» amount of ISO cells: «powerSetIsoAmount.get(lr)»
		# PD«logicRegionID.get(lr)» amount of ISO cells in full design: «powerSetIsoAmount_full.get(lr)»		
		create_isolation_rule -name iso«logicRegionID.get(lr)» -from PD«logicRegionID.get(lr)»\
		-to {PDdef «FOR reg: LrCrossIsoMap.get(lr)»PD«logicRegionID.get(reg)» «ENDFOR»}\
		-isolation_condition {powerController_0/iso_en«logicRegionID.get(lr)»} -isolation_output high -isolation_target from
		
		«ENDFOR»
		'''
	}	
	
	def createStateRetentionRules(){
		'''
		«FOR lr: powerSets» «IF logicRegionsSeqMap.get(lr)»
		create_state_retention_rule -name st«logicRegionID.get(lr)» -domain PD«logicRegionID.get(lr)»\
		-restore_edge {!powerController_0/rstr_en«logicRegionID.get(lr)»}\
		-save_edge {powerController_0/save_en«logicRegionID.get(lr)»}\
		-target_type both -secondary_domain PDdef
		
		«ENDIF»
		«ENDFOR»
		'''
	}
	
	
	def updatePowerMode(){
		'''
		#replace cpf/sparc_exu.sdc with your PATH/sdcFile.sdc
		update_power_mode -name PMdef -sdc_files cpf/sparc_exu.sdc
		«FOR network : networks»		
		update_power_mode -name PM«configManager.getNetworkId(network.getSimpleName())» -sdc_files cpf/sparc_exu.sdc
		«ENDFOR»
		'''		
	}
	
	def updateIsolationRules(){
		'''
		«FOR lr: powerSets»
		#update_isolation_rules -names iso«logicRegionID.get(lr)» -location to/from -cells ...
		«ENDFOR»
		'''	
	}
	
	def createPowerNets(){
		'''
		create_power_nets -nets {«FOR lr: powerSets» VDD_SW«logicRegionID.get(lr)»«ENDFOR»} -internal
		'''
	}
	
	def createGlobalConnection(){
		'''
		«FOR lr: powerSets»
		create_global_connection -domain PD«logicRegionID.get(lr)» -net VDD_SW«logicRegionID.get(lr)» -pins VDD
		create_global_connection -domain PD«logicRegionID.get(lr)» -net TVDD -pins TVDD
		create_global_connection -domain PD«logicRegionID.get(lr)» -net VSS -pins VSS
		
		«ENDFOR»
		'''
	}
	
	def createPoweSwitch(){
		'''
		«FOR lr: powerSets»
		create_power_switch_rule -name SW«logicRegionID.get(lr)» -domain PD«logicRegionID.get(lr)» -external_power_net TVDD
		«ENDFOR»
		'''
	}
	
	def updatePowerDomain(){
		'''
		«FOR lr: powerSets»
		update_power_domain -name PD«logicRegionID.get(lr)» -primary_power_net VDD_SW«logicRegionID.get(lr)» -primary_ground_net VSS
		«ENDFOR»
		'''
	}
	
	def createAnalysisView(){
		'''
		create_analysis_view -name AV_PMdef_bc -mode PMdef\
		-domain_corners {PDdef@BC «FOR lr: powerSets»PD«logicRegionID.get(lr)»@BC «ENDFOR»}
		create_analysis_view -name AV_PMdef_wc -mode PMdef\
		-domain_corners {PDdef@WC «FOR lr: powerSets»PD«logicRegionID.get(lr)»@WC «ENDFOR»}
		
		«FOR network : networks»
		create_analysis_view -name AV_PM«configManager.getNetworkId(network.getSimpleName())»_bc -mode PM«configManager.getNetworkId(network.getSimpleName())»\
		-domain_corners {PDdef@BC «FOR lr: powerSets»PD«logicRegionID.get(lr)»@BC «ENDFOR»}
		create_analysis_view -name AV_PM«configManager.getNetworkId(network.getSimpleName())»_wc -mode PM«configManager.getNetworkId(network.getSimpleName())»\
		-domain_corners {PDdef@WC «FOR lr: powerSets»PD«logicRegionID.get(lr)»@WC «ENDFOR»}
		
		«ENDFOR»
		'''
	}
	
	def printCPF(Network network, 
		List<SboxLut> luts, 
		Map<String,Set<String>> logicRegions, 
		Map<String,Set<String>> netRegions, 
		Map<String, Integer> logicRegionID, 
		ConfigManager configManager, 
		Set<String> powerSets,
		Map<String,Boolean> logicRegionsSeqMap){
		// Initialize members
		this.logicRegions = logicRegions;
		this.netRegions = netRegions;
		this.logicRegionID = logicRegionID;
		this.luts = luts; 
		this.configManager = configManager;
		this.powerSets = powerSets;
		this.logicRegionsSeqMap = logicRegionsSeqMap;
		
		networks = new ArrayList<Network>();
		LrCrossIsoMap = new HashMap<String,HashSet<String>>();
		Compl_LrCrossIsoMap = new HashMap<String,HashSet<String>>();
		powerSetIsoAmount = new HashMap<String,Integer>();
		powerSetIsoAmount_full = new HashMap<String,Integer>();
		
		computeNets();
		findLrCrossIso();
		compl_LrCrossIso();
		findIsoCellsAmount(network);
		
		
		'''
		«headerComments()»
		
		set_cpf_version 1.1
		set_hierarchy_separator /
		
		###############################################################################
		# 			Technology part of the CPF
		###############################################################################
		
		###############################################################################
		#
		#  THIS PART HAS TO BE MODIFIED DEPENDING ON YOUR TECHNOLOGY LIBRARIES!!!!
		#
		###############################################################################
						
		# define the library sets
		define_library_set -name set1_wc -libraries {\
		cpf/libraries/lib/tcbn90lphpwc.lib\
		cpf/libraries/lib/tcbn90lphpwc0d90d9.lib\
		cpf/libraries/lib/tcbn90lphpcgwc.lib}
		
		define_library_set -name set1_bc -libraries {\
		cpf/libraries/lib/tcbn90lphpbc.lib\
		cpf/libraries/lib/tcbn90lphpbc1d11d1.lib\
		cpf/libraries/lib/tcbn90lphpcgbc.lib}
		
		#define the isolation cells
		define_isolation_cell -cells {ISOH* ISOL*} -enable ISO\
		-power VDD -ground VSS  -valid_location on
		
		# define the always on cell
		define_always_on_cell -cells {PTBUFFD* PTDFCND*} -power_switchable VDD -power TVDD -ground VSS
		
		
		# define the state retention cell
		define_state_retention_cell -cells RSDFCD* \
		-power_switchable VDD -power TVDD -ground VSS -save_function SAVE -restore_function !NRESTORE \
		-always_on_pins {NRESTORE SAVE} -clock_pin {CP} 
		#-always_on_components {save_data}
		
		define_state_retention_cell -cells RSDFCRD* \
		-power_switchable VDD -power TVDD -ground VSS -save_function SAVE -restore_function !NRESTORE \
		-always_on_pins {CDN NRESTORE SAVE}  
		#-always_on_components {save_data}
		
		define_state_retention_cell -cells RSDFCSD* \
		-power_switchable VDD -power TVDD -ground VSS -save_function SAVE -restore_function !NRESTORE \
		-always_on_pins {SDN NRESTORE SAVE} -clock_pin {CP} 
		#-always_on_components {save_data}
		
		define_state_retention_cell -cells RSDFCSRD* \
		-power_switchable VDD -power TVDD -ground VSS -save_function SAVE -restore_function !NRESTORE \
		-always_on_pins {CDN SDN NRESTORE SAVE} -clock_pin {CP} 
		#-always_on_components {save_data}
		
		# define the power switch cells
		define_power_switch_cell -cells "HDRDID*" \
		-stage_1_enable NSLEEPIN1 -stage_1_output NSLEEPOUT1\
		-stage_2_enable NSLEEPIN2 -stage_2_output NSLEEPOUT2\
		-type header -power_switchable VDD -power TVDD
		
		define_power_switch_cell -cells "HDRSID*" \
		-stage_1_enable NSLEEPIN -stage_1_output NSLEEPOUT\
		-type header -power_switchable VDD -power TVDD

				
		###############################################################################
		# 			Design part of the CPF
		###############################################################################
		
		#identify the design for which the CPF is created
		set_design multi_dataflow
		
		# create power domains
		«createPowerDomains()»
		
		# create nominal conditions
		create_nominal_condition -name off -voltage 0
		create_nominal_condition -name on -voltage 1.08		
		
		# create power modes
		«createPowerModes()»
		
		# associate library sets with nominal conditions
		update_nominal_condition -name on -library_set set1_wc
		
		# create rules for isolation logic insertion
		«createIsolationRules()»		
		
		# create rules for state retention insertion
		«createStateRetentionRules()»
		
		###############################################################################
		# 			Additional information for Logic Synthesis
		###############################################################################
		
		# specify power target
		set_power_target -leakage 30 -dynamic 250
		
		# specify timing constraints
		«updatePowerMode()»
		#update_power_mode\
		#-name PMdef -activity_file FILE_VCD.vcd\
		#-activity_file_weight 100
		
		# update the rules with implementation info
		#updateIsolationRules()
		
		###############################################################################
		# 			Additional information for Physical Implementation
		###############################################################################
		
		# declare power and ground nets
		create_power_nets -nets TVDD -voltage 1.08
		«createPowerNets()»
		create_ground_nets -nets VSS -voltage 0
		
		# (optional) create global connections
		create_global_connection -net TVDD -pins VDD
		create_global_connection -net VSS -pins VSS
		«createGlobalConnection()»
		
		# rules for power switch insertion
		«createPoweSwitch()»
		
		# add implementation info for power domains
		update_power_domain -name PDdef -primary_power_net TVDD -primary_ground_net VSS
		
		«updatePowerDomain()»
		
		# create operating corners
		create_operating_corner -name BC \
		-process 1 -temperature 0 -voltage 1.32 -library_set set1_bc
		create_operating_corner -name WC \
		-process 1 -temperature 125 -voltage 1.08 -library_set set1_wc
		
		# create analysis view
		«createAnalysisView()»
		
		# indicate when the power information for the design ends
		end_design
		'''
	}
	
	
	
	

}
	
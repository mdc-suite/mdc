package it.mdc.tool.powerSaving

import java.text.SimpleDateFormat
import java.util.Date
import java.util.List
import net.sf.orcc.df.Network

import it.mdc.tool.core.sboxManagement.SboxLut
import it.mdc.tool.core.ConfigManager
import java.util.ArrayList
import java.util.Map
import java.util.Set
import java.util.HashSet
import java.util.HashMap
import net.sf.orcc.df.Connection
import net.sf.orcc.util.OrccLogger
import net.sf.orcc.df.Actor
import net.sf.orcc.df.Port
import net.sf.orcc.graph.Edge

/**
 * A CPF Template file printer.
 * The printer is created ad hoc for the generated multi-functional network and for the identified Logic Regions.
 * 
 * The CPF needs to be updated with technology library data.
 * This file can be used only for ASIC technology.
 * 
 * @author Tiziana Fanni
 */
class CpfPrinter {
	private Map<String,Map<String,Map<String,String>>> modCommSignals;
	
	private static final String ACTOR = "actor";

	private static final String KIND = "kind";
	private static final String DIR = "dir";
	private static final String SIZE = "size";
	
	/**Config Manager description*/
	var ConfigManager configManager;
	
	/**Look Up Table */
	var List<SboxLut> luts;
	
	/**List of input networks*/
	var List<Network> networks;
	
	/** Map of instances for each LR*/
	var Map<String,Set<String>> logicRegions;
	
	/** Map of LRs for each network */
	var Map<String,Set<String>> netRegions;
	
	/** Map with one ID for each LR */
	var Map<String, Integer> logicRegionID;
	
	/**Set of switchable LRs */
	var Set<String> powerSets;
	
	/**Map of ON PDs, for each OFF PD. */
	var Map<String,HashSet<String>> LrCrossIsoMap;
	
	/**Map of OFF PDs, for each OFF PD. */
	var Map<String,HashSet<String>> offPDsMap;
	
	/**Map of ON PDs, for each ON PD. */
	var Map<String,HashSet<String>> Compl_LrCrossIsoMap;
	
	var Map<String, Integer> powerSetIsoAmount;
	
	/** For each Logic Regions in this map, the key value is true if the LR is sequential, and false if LR is purely combinatorial*/
	var Map<String,Boolean> logicRegionsSeqMap;
	
	/**Print header comments*/
	def headerComments(){				
		var dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		var date = new Date();
		'''
		###############################################################################
		# CPF Template file automatically generated by:
		#  Multi-Dataflow Composer tool - Power Saving
		#
		# The printer is ad hoc for the generated multi-functional network and for the identified Logic Regions.
		# he CPF needs to be updated with technology library data.
		# Date: «dateFormat.format(date)»
		###############################################################################
		'''	
	}

	
	/**For each PDx, find PDs which are ON when PDx is off*/
	def findLrCrossIso(){
		for(String lr : powerSets) {
			LrCrossIsoMap.put(lr, new HashSet<String>());		
			for(String net : netRegions.keySet()) {	
				if(!netRegions.get(net).contains(lr)){
					for(String region : netRegions.get(net))
						if(!LrCrossIsoMap.get(lr).contains(region) && powerSets.contains(region)){
							LrCrossIsoMap.get(lr).add(region)													
						}
					}
				}
			}
		}

	/**For each PDx, find PDs which are OFF when PDx is OFF*/	
	def findOffLr(){
		for(String lr : powerSets) {
	//		System.out.println("lr is " + lr);
			offPDsMap.put(lr, new HashSet<String>());		
				for(String cross_lr: powerSets)
					if(!LrCrossIsoMap.get(lr).contains(cross_lr))
							offPDsMap.get(lr).add(cross_lr);
	//	System.out.println("offPDs.get(lr) is " + offPDsMap.get(lr));
		}
	}

		
		
	/**For each PDx, find PDs which are ON when PDx is on*/
	def compl_LrCrossIso(){
		for(String lr : powerSets) {
			Compl_LrCrossIsoMap.put(lr, new HashSet<String>());		
				for(String cross_lr: powerSets)
					if(!LrCrossIsoMap.get(lr).contains(cross_lr))
							Compl_LrCrossIsoMap.get(lr).add(cross_lr);
		}
	}	
	

/*«FOR output : actor.outputs»
			«FOR commSigId : modCommSignals.get(ACTOR).keySet»
			«IF isOutputSide(ACTOR,commSigId)»
			wire «getCommSigDimension(ACTOR,actor,commSigId,output)»«getModName(ACTOR)»«actor.label»_«getSigName(ACTOR,commSigId,output)»;
			«ENDIF»
			«ENDFOR»
			«IF modNames.containsKey(SUCC)»
			«FOR commSigId : modCommSignals.get(SUCC).keySet»
			«IF isOutputSide(SUCC,commSigId)»
			wire «getCommSigDimension(SUCC,actor,commSigId,output)»«getModName(SUCC)»«actor.label»_«getSigName(SUCC,commSigId,output)»;
			«ENDIF»
			«ENDFOR»
			«ENDIF»
			«ENDFOR»;*/
		
	def boolean isInputSide(String module, String commSigId) {
		if( (modCommSignals.get(module).get(commSigId).get(KIND).equals("input")
			&& modCommSignals.get(module).get(commSigId).get(DIR).equals("direct"))
			|| (modCommSignals.get(module).get(commSigId).get(KIND).equals("output")
			&& modCommSignals.get(module).get(commSigId).get(DIR).equals("reverse")) ) {
			return true		
		} else {
			return false
		}
	}
	
	def boolean isOutputSide(String module, String commSigId) {
		if( (modCommSignals.get(module).get(commSigId).get(KIND).equals("output")
			&& modCommSignals.get(module).get(commSigId).get(DIR).equals("direct"))
			|| (modCommSignals.get(module).get(commSigId).get(KIND).equals("input")
			&& modCommSignals.get(module).get(commSigId).get(DIR).equals("reverse")) ) {
			return true		
		} else {
			return false
		}
	}	
	
		def int getCommSigSize(String module, Actor actor, String commSigId, Port port) {
		if (modCommSignals.get(module).get(commSigId).get(SIZE).equals("variable")) {
			return port.type.sizeInBits
		} else if (modCommSignals.get(module).get(commSigId).get(SIZE).equals("broadcast")) {
			if (actor !== null) {
			 	if (actor.outgoingPortMap.containsKey(port)) {
					if (actor.outgoingPortMap.get(port).get(0).hasAttribute("broadcast")) {
						actor.outgoingPortMap.get(port).size
					} else {
						1
					}
				} else {
					1
				}
			} else if (port !== null) {
				if(port.outgoing.size != 0) {
					if ((port.outgoing.get(0) as Connection).hasAttribute("broadcast")) {
						port.outgoing.size
					} else {
						1
					}
				
				} else {
					1
				}
			} else {
				1
			}
		} else {	
			return Integer.parseInt(modCommSignals.get(module).get(commSigId).get(SIZE))
		}
	}		

		/** find isolation cells number*/
	def findIsoCellsAmount(Network network){
		for(String lr : powerSets) {
			System.out.println("lr " + lr);
			powerSetIsoAmount.put(lr,0);
			for(Actor actor : network.getChildren().filter(typeof(Actor))) {				
				if(logicRegions.get(lr).contains(actor.getSimpleName())){
					var flag = true;
					for(Connection connection: actor.getOutgoing().filter(typeof(Connection))) {						
						if(!logicRegions.get(lr).contains(connection.target.label)){	
									for(String crossLr : offPDsMap.get(lr)){
											if(logicRegions.get(crossLr).contains(connection.target.label)){
												flag = false;}
											}
						if(flag){
							for(String commSigId : modCommSignals.get(ACTOR).keySet){
									if (isOutputSide(ACTOR,commSigId)){
										//gestire i broadcast. nella stima li conta due volte, ma le celle di isolamento sono messe al
										// source prima del broadcast
										System.out.println("connection is " + connection);
										System.out.println("connection.target is " + connection.target.label);
										System.out.println("connection size " + getCommSigSize(ACTOR,actor,commSigId,connection.getSourcePort()));
										powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + getCommSigSize(ACTOR,actor,commSigId,connection.getSourcePort()));
										}	
							}
						}			
						}

					}
				}
				
				
				/*if(logicRegions.get(lr).contains(actor) &&
						!logicRegions.get(lr).contains(actor.getIncoming())) {					
					var flag = true;													
					for(String crossLr : Compl_LrCrossIsoMap.get(lr)){
						if(logicRegions.get(crossLr).contains(actor.getIncoming())){
							flag = false;}								
					}
					if(flag){
					for(output : actor.outputs)
						for(String commSigId : modCommSignals.get(ACTOR).keySet)
							if (isInputSide(ACTOR,commSigId))
								powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + getCommSigSize(ACTOR,actor,commSigId,output));
							}
				}*/
			}
		}
	}	
		
		
//	/** find isolation cells number (only for ALBA custom protocol)*/
	/*def findIsoCellsAmount(Network network){
		for(String lr : powerSets) {
			powerSetIsoAmount.put(lr,0);
			powerSetIsoAmount_full.put(lr,0);	
				
			for(Connection connection : network.connections) {
				
				if(logicRegions.get(lr).contains(connection.source.label) &&
						!logicRegions.get(lr).contains(connection.target.label)) {
							var size = connection.size
										if(size==null) {
											size = connection.sourcePort.type.sizeInBits
										}						
							var flag = true;													
							for(String crossLr : Compl_LrCrossIsoMap.get(lr)){
								if(logicRegions.get(crossLr).contains(connection.target.label)){
									flag = false;}								
							}
								if(flag){
										
								 powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size + 16 + 1);
								 //powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size);
								}
								powerSetIsoAmount_full.put(lr,powerSetIsoAmount_full.get(lr)+ size + 16 + 1);
				}
				
				if (logicRegions.get(lr).contains(connection.target.label) &&
						!logicRegions.get(lr).contains(connection.source.label)) {						
						var flag = true; 
						for(String crossLr : Compl_LrCrossIsoMap.get(lr)){
							if (logicRegions.get(crossLr).contains(connection.source.label))
								flag = false;
						}
							if(flag){
								powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + 1);
								//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
							}
							powerSetIsoAmount_full.put(lr,powerSetIsoAmount_full.get(lr) + 1);
				}
			}
		}
	}*/

	
//		// find isolation cells number (only for ALBA custom protocol)
//	def findIsoCellsAmount(Network network){
//		for(String lr : powerSets) {
//			powerSetIsoAmount.put(lr,0);		
//			for(Connection connection : network.connections) {
//				if(logicRegions.get(lr).contains(connection.source.label) &&
//						!logicRegions.get(lr).contains(connection.target.label)) {
//							var size = connection.size
//							if(size==null) {
//								size = connection.sourcePort.type.sizeInBits
//							}
//							//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + size + 16 + 1);
//							powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
//				}
//				if (logicRegions.get(lr).contains(connection.target.label) &&
//						!logicRegions.get(lr).contains(connection.source.label))  {
//							//powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr) + 2);
//							powerSetIsoAmount.put(lr,powerSetIsoAmount.get(lr));
//				}
//			}
//			
//		}
//		
//	}
	
	
	def computeNets() {
		networks.addAll(luts.get(0).getNetworks());
	}
	
	/**
	 * For each identified Switchable Logic Region,
	 * create the power domain in the CPF file.
	 * A Logic Region is switchable when it is not Always ON (not shared by all of the networks in the multi-functional architecture).
	 */
	def createPowerDomains() {			
		'''
		create_power_domain -name PDdef -default	
					
		«FOR lr: powerSets»
		create_power_domain -name PD«logicRegionID.get(lr)» -instances {«FOR inst: logicRegions.get(lr)»«IF inst.contains("sbox")»«inst»«ELSE»actor_«inst»«ENDIF» «ENDFOR»}\
		-shutoff_condition {powerController_0/pw_switch_en«logicRegionID.get(lr)»} -base_domains {PDdef}
		
		«ENDFOR»			
		'''
	}	
	
	/**
	 * For each functionality of the multi-functional network,
	 * corresponding to one of the original input dataflow networks,
	 * create a different Power Mode.
	 */
	def createPowerModes(){	
		'''	
		create_power_mode -name PMdef -domain_conditions {PDdef@high «FOR lr: powerSets»PD«logicRegionID.get(lr)»@high «ENDFOR»} -default
		«FOR network : networks»
		#«network.getSimpleName()»
		create_power_mode -name PM«configManager.getNetworkId(network.getSimpleName())» \
		-domain_conditions {PDdef@high «FOR reg: powerSets»«IF netRegions.get(network.getSimpleName()).contains(reg)»PD«logicRegionID.get(reg)»@high «ELSE»PD«logicRegionID.get(reg)»@off «ENDIF» «ENDFOR»}
				
		«ENDFOR»		
		'''
	}
	
	/**
	 * For each identified Logic Regions,
	 * create an Isolation Rule
	 */
	def createIsolationRules(){
		'''
		«FOR lr: powerSets»
		# PD«logicRegionID.get(lr)» amount of ISO cells: «powerSetIsoAmount.get(lr)»
		create_isolation_rule -name iso«logicRegionID.get(lr)» -from PD«logicRegionID.get(lr)»\
		-to {PDdef «FOR reg: LrCrossIsoMap.get(lr)»PD«logicRegionID.get(reg)» «ENDFOR»} -exclude {«FOR region: powerSets» powerController_0/sw_ack«logicRegionID.get(region)»«ENDFOR»}\
		-isolation_condition {!powerController_0/iso_en«logicRegionID.get(lr)»} -isolation_output low -isolation_target from
		update_isolation_rules -names iso«logicRegionID.get(lr)» -location to
		
		«ENDFOR»
		'''
	}	
	/**
	 * For each identified Logic Regions,
	 * create an State Retention Rule
	 */	
	def createStateRetentionRules(){
		'''
		«FOR lr: powerSets» «IF logicRegionsSeqMap.get(lr)»
		create_state_retention_rule -name st«logicRegionID.get(lr)» -domain PD«logicRegionID.get(lr)»\
		-restore_edge {!powerController_0/rtn_en«logicRegionID.get(lr)»}\
		-save_edge {powerController_0/rtn_en«logicRegionID.get(lr)»}\
		-target_type both -secondary_domain PDdef
		update_state_retention_rules -names st«logicRegionID.get(lr)» -cells {RDFF* SRDFF*}
		
		«ENDIF»
		«ENDFOR»
		'''
	}
	
	
	/**
	 * identify always on drivers
	 */	
	def identifyAoDrivers(){
		'''
		«FOR lr: powerSets» «IF logicRegionsSeqMap.get(lr)»
		identify_always_on_driver -pins {powerController_0/rtn_en«logicRegionID.get(lr)» }
		«ENDIF»
		«ENDFOR»
		'''
	}
	
	def updatePowerMode(){
		'''
		#replace ./DataIn/sdc/fastmode.sdc with your PATH/sdcFile.sdc
		update_power_mode -name PMdef -sdc_files ./DataIn/sdc/fastmode.sdc
		«FOR network : networks»		
		update_power_mode -name PM«configManager.getNetworkId(network.getSimpleName())» -sdc_files ./DataIn/sdc/fastmode.sdc
		«ENDFOR»
		'''		
	}
	
	def updateIsolationRules(){
		'''
		«FOR lr: powerSets»
		#update_isolation_rules -names iso«logicRegionID.get(lr)» -location to/from -cells ...
		«ENDFOR»
		'''	
	}
	
	/**
	 * Create the Virtual Power Networks
	 */
	def createPowerNets(){
		'''
		create_power_nets -nets {«FOR lr: powerSets» VDD_SW«logicRegionID.get(lr)»«ENDFOR»} -internal -voltage {0.0:1.2}
		'''
	}
	
	/**
	 * Specify the connection between the power nets and the power pins
	 */
	def createGlobalConnection(){
		'''
		«FOR lr: powerSets»
		create_global_connection -domain PD«logicRegionID.get(lr)» -net VDD_SW«logicRegionID.get(lr)» -pins VDD
		create_global_connection -domain PD«logicRegionID.get(lr)» -net VSS -pins VSS
		
		«ENDFOR»
		'''
	}
	
	/**
	 * For each identified Logic Region
	 * create a Power Switch Rule
	 */
	def createPoweSwitch(){
		'''
		«FOR lr: powerSets»
		create_power_switch_rule -name SW«logicRegionID.get(lr)» -domain PD«logicRegionID.get(lr)» -external_power_net VDD
		update_power_switch_rule -name SW1 -enable_condition_1 {!powerController_0/pw_switch_en«logicRegionID.get(lr)»} -acknowledge_receiver_1 sw_ack«logicRegionID.get(lr)» -cells "HSWX1"
		«ENDFOR»
		'''
	}
	
	def updatePowerDomain(){
		'''
		«FOR lr: powerSets»
		update_power_domain -name PD«logicRegionID.get(lr)» -primary_power_net VDD_SW«logicRegionID.get(lr)» -primary_ground_net VSS
		«ENDFOR»
		'''
	}
	
	/**
	 * For each Power Mode create different Analysis Views
	 */
	def createAnalysisView(){
		'''
		create_analysis_view -name AV_PMdef_bc -mode PMdef\
		-domain_corners {PDdef@BC_fast «FOR lr: powerSets»PD«logicRegionID.get(lr)»@BC_fast «ENDFOR»}
		create_analysis_view -name AV_PMdef_wc -mode PMdef\
		-domain_corners {PDdef@WC_fast «FOR lr: powerSets»PD«logicRegionID.get(lr)»@WC_fast «ENDFOR»}
		
		«FOR network : networks»
		create_analysis_view -name AV_PM«configManager.getNetworkId(network.getSimpleName())»_bc -mode PM«configManager.getNetworkId(network.getSimpleName())»\
		-domain_corners {PDdef@BC_fast «FOR lr: powerSets»«IF netRegions.get(network.getSimpleName()).contains(lr)»PD«logicRegionID.get(lr)»@BC_fast«ELSE»PD«logicRegionID.get(lr)»@BC_sleep «ENDIF» «ENDFOR»}
		create_analysis_view -name AV_PM«configManager.getNetworkId(network.getSimpleName())»_wc -mode PM«configManager.getNetworkId(network.getSimpleName())»\
		-domain_corners {PDdef@WC_fast «FOR lr: powerSets»«IF netRegions.get(network.getSimpleName()).contains(lr)»PD«logicRegionID.get(lr)»@WC_fast«ELSE»PD«logicRegionID.get(lr)»@WC_sleep «ENDIF» «ENDFOR»}
				
		«ENDFOR»
		'''
	}
	
	
	/**
	 * Print the Common Power Format file
	 */
	def printCPF(Network network, 
		List<SboxLut> luts, 
		Map<String,Set<String>> logicRegions, 
		Map<String,Set<String>> netRegions, 
		Map<String, Integer> logicRegionID, 
		ConfigManager configManager, 
		Set<String> powerSets,
		Map<String,Boolean> logicRegionsSeqMap,
		Map<String,Map<String,Map<String,String>>> modCommSignals){
		// Initialize members
		this.logicRegions = logicRegions;
		this.netRegions = netRegions;
		this.logicRegionID = logicRegionID;
		this.luts = luts; 
		this.configManager = configManager;
		this.powerSets = powerSets;
		this.logicRegionsSeqMap = logicRegionsSeqMap;
		this.modCommSignals = modCommSignals;
		
		networks = new ArrayList<Network>();
		LrCrossIsoMap = new HashMap<String,HashSet<String>>();
		Compl_LrCrossIsoMap = new HashMap<String,HashSet<String>>();
		offPDsMap = new HashMap<String,HashSet<String>>();
		powerSetIsoAmount = new HashMap<String,Integer>();
		
		computeNets();
		findLrCrossIso();
		compl_LrCrossIso();
		findOffLr();
		findIsoCellsAmount(network);
		
		
		'''
		«headerComments()»
		
		set_cpf_version 2.0
		set_hierarchy_separator /
		
		###############################################################################
		# 			Technology part of the CPF
		###############################################################################
		
		###############################################################################
		#
		#  THIS PART HAS TO BE MODIFIED DEPENDING ON YOUR TECHNOLOGY LIBRARIES!!!!
		#
		###############################################################################
						
		############################
		## Define WC library sets ##
		## SS/0.9*VDD/125C        ##
		############################
		define_library_set -name gpdk045_wc_hi_lib  -libraries {\
		 ../Library/timing/slow_vdd1v2_basicCells.lib \
		 ../Library/timing/slow_vdd1v2_extvdd1v2.lib \
		 ../Library/timing/slow_vdd1v2_extvdd1v0.lib \
		 ../Library/timing/slow_vdd1v0_extvdd1v2.lib \
		 ../Library/timing/slow_vdd1v2_basicCells_lvt.lib }
		
		define_library_set -name gpdk045_wc_lo_lib  -libraries {\
		 ../Library/timing/slow_vdd1v0_basicCells.lib \
		 ../Library/timing/slow_vdd1v0_extvdd1v0.lib \
		 ../Library/timing/slow_vdd1v0_extvdd1v2.lib \
		 ../Library/timing/slow_vdd1v0_basicCells_lvt.lib }
		 
		############################
		## Define BC library sets ##
		##  FF/1.1*VDD/0C         ##
		############################
		define_library_set -name gpdk045_bc_hi_lib  -libraries {\
		 ../Library/timing/fast_vdd1v2_basicCells.lib \
		 ../Library/timing/fast_vdd1v2_extvdd1v2.lib \
		 ../Library/timing/fast_vdd1v2_extvdd1v0.lib \
		 ../Library/timing/fast_vdd1v0_extvdd1v2.lib \
		 ../Library/timing/fast_vdd1v2_basicCells_lvt.lib }
		
		define_library_set -name gpdk045_bc_lo_lib  -libraries {\
		 ../Library/timing/fast_vdd1v0_basicCells.lib \
		 ../Library/timing/fast_vdd1v0_extvdd1v0.lib \
		 ../Library/timing/fast_vdd1v0_extvdd1v2.lib \
		 ../Library/timing/fast_vdd1v0_basicCells_lvt.lib }
		
		#define the isolation cells
		define_isolation_cell -power VDD -ground VSS -enable ISO -valid_location to -cells "ISOLX1_ON"
		
		# define the always on cell
		define_always_on_cell -cells "PBUFX2" -power_switchable VDD -power ExtVDD -ground VSS 
		
		
		# define the state retention cell
		define_state_retention_cell -cells {RDFF* SRDFF*} -ground VSS -power ExtVDD -power_switchable VDD -save_function !RT -restore_function RT
		
		
		# define the power switch cells
		define_power_switch_cell -power_switchable VDD -power ExtVDD -stage_1_enable !PSO -stage_1_output PSO_out -type header -cells "HSWX1"

				
		###############################################################################
		# 			Design part of the CPF
		###############################################################################
		
		#identify the design for which the CPF is created
		set_design multi_dataflow
		
		# create power domains
		«createPowerDomains()»
		
		# create nominal conditions
		create_nominal_condition -name high -voltage 1.08 -state on
		# associate library sets with nominal conditions
		update_nominal_condition -name high -library_set gpdk045_wc_hi_lib
		create_nominal_condition -name off  -voltage 0.0 -state off		
		
		# create power modes
		«createPowerModes()»

		
		# create rules for isolation logic insertion
		«createIsolationRules()»		
		
		# create rules for state retention insertion
		«createStateRetentionRules()»
		
		# identify always on drivers
		«identifyAoDrivers()»
		
		###############################################################################
		# 			Additional information for Logic Synthesis
		###############################################################################
		
		# specify timing constraints
		«updatePowerMode()»
		#update_power_mode\
		#-name PMdef -activity_file FILE_VCD.vcd\
		#-activity_file_weight 100
		
		###############################################################################
		# 			Additional information for Physical Implementation
		###############################################################################
		
		# declare power and ground nets
		create_power_nets  -nets VDD -voltage {1.2}
		«createPowerNets()»
		create_ground_nets -nets VSS -voltage 0
		
		# (optional) create global connections
		create_global_connection -net VDD -pins VDD -domain PDdef
		create_global_connection -net VSS -pins VSS -domain PDdef
		
		«createGlobalConnection()»
		
		# rules for power switch insertion
		«createPoweSwitch()»
		
		# add implementation info for power domains
		update_power_domain -name PDdef -primary_power_net VDD -primary_ground_net VSS
		«updatePowerDomain()»
		
		# create operating corners
		create_operating_corner -name WC_fast   -library_set gpdk045_wc_hi_lib  -process 1  -voltage 1.08   -temperature 125
		create_operating_corner -name BC_fast   -library_set gpdk045_bc_hi_lib  -process 1  -voltage 1.32   -temperature 0
		
		create_operating_corner -name WC_sleep  -library_set gpdk045_wc_hi_lib  -process 1  -voltage 0.0    -temperature 125
		create_operating_corner -name BC_sleep -library_set gpdk045_bc_hi_lib  -process 1  -voltage 0.0    -temperature 0
		
		# create analysis view
		«createAnalysisView()»
		
		# indicate when the power information for the design ends
		end_design
		'''
	}
	
	
	
	

}
	
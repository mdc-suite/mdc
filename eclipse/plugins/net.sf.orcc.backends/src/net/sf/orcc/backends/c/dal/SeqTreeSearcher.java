package net.sf.orcc.backends.c.dal;

import net.sf.orcc.df.Action;
import net.sf.orcc.df.Actor;
import net.sf.orcc.util.OrccLogger;

/**
 * Class explores the Peek Sequence Tree generated by the whole algorithm
 *
 * @author Jani Boutellier
 */
public class SeqTreeSearcher {

	private SeqTreeNode ndNode;
	private Actor theActor;

	public SeqTreeSearcher(Actor actor) {
		ndNode = null;
		theActor = actor;
	}

	public void search(SeqTreeNode node, int depth, boolean verbose) {
		if (node != null) {
			String tokenStr = new String();
			for (Token token : node.getProcessed()) {
				tokenStr = tokenStr.concat(token.getTargetVar().getName() + " ");
			}
			String tabStr = new String();
			for (int i = 0; i < depth + 1; i ++) {
				tabStr = tabStr.concat(" ");
			}
			String actionStr = new String();
			for (Action action : node.getActions()) {
				actionStr = actionStr.concat(action.getName() + " ");
			}
			if (verbose) {
				if (node.getConstraints() == null) {
					OrccLogger.traceln(tabStr + "root+" + depth + ":(no constraints){" + tokenStr + "} --> " + actionStr);
				} else {
					OrccLogger.traceln(tabStr + "root+" + depth + ":" + node.getConstraints().toString() + "{" + tokenStr + "} --> " + actionStr);
				}
			}
			if (node.getChildren().size() == 0) {
				if (node.getActions().size() > 1) {
					PriorityResolver resolver = new PriorityResolver(theActor);
					if (resolver.resolve(node.getActions(), tokenStr) == false) {
						ndNode = node;
					}
				}
			} else {
				for (SeqTreeNode child : node.getChildren()) {
					search(child, depth + 1, verbose);
				}
			}
		}
	}

	public SeqTreeNode getNondeterministic() {
		return ndNode;
	}

}
